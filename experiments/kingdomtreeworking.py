# -*- coding: utf-8 -*-
# at top of your module
"""kingdomTreeWorking

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vHluSPtJg8CNMrO9Th9oSh992rIlb9od
"""
import random
import numpy as np
from collections import defaultdict
import time
import heapq
import math
import torch
from multiprocessing import Pool, cpu_count
import bisect

from collections import deque
import copy

def bfs_find_one_path(grid, base, resource_coords):
    rows, cols = len(grid), len(grid[0])
    resource_set = set(resource_coords)
    visited = {base}
    queue   = deque([base])
    parent  = {base: None}

    while queue:
        cur = queue.popleft()

        # check for resource
        if cur in resource_set:
            # reconstruct path
            path = []
            node = cur
            while node is not None:
                path.append(node)
                node = parent[node]
            return list(reversed(path))

        # explore neighbors
        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr, nc = cur[0] + dr, cur[1] + dc
            nxt = (nr, nc)

            # bounds + walkable check
            if not (0 <= nr < rows and 0 <= nc < cols):
                continue
            if grid[nr][nc] != 1:
                continue
            if cur == base and nxt in resource_set:
              continue

            if nxt not in visited:
                visited.add(nxt)
                parent[nxt] = cur
                queue.append(nxt)
    return []

def find_all_paths_to_resources(grid, base, resource_coords): #ERROR WHEN RESOURCE IS ADJACENT TO BASE
    working_grid = copy.deepcopy(grid)  # to not modify original grid
    paths = []

    while True: #ISSUE IS HERE: path returns with path of size 2, it counts as a path
        path = bfs_find_one_path(working_grid, base, resource_coords)
        if not path:
            break  # No more paths available

        # Block the path (except base and resource)
        for cell in path[1:-1]:  # ignore base (first cell) and resource (last cell)
            r, c = cell
            working_grid[r][c] = 0  # mark as unwalkable

        path_rev = list(reversed(path))
        path = path[1:]
        path.extend(path_rev[1:])
        paths.append(path)

    return paths

def bfs_find_one_worker_path_to_resource(grid, worker, resource_coords):
    rows = len(grid)
    cols = len(grid[0])
    queue = deque([(worker, [worker])])
    visited = set()
    visited.add(worker)

    resource_set = set(resource_coords)

    while queue:
        (r, c), path = queue.popleft()

        if (r, c) in resource_set:
          return path  # found a resource, return the path

        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr][nc] == 1 and (nr, nc) not in visited:
                    queue.append(((nr, nc), path + [(nr, nc)]))
                    visited.add((nr, nc))
    return [] #why does returning path fix this??

def bfs_find_one_worker_path_to_base(grid, worker, base):
    rows = len(grid)
    cols = len(grid[0])
    queue = deque([(worker, [worker])])
    visited = set()
    visited.add(worker)

    while queue:
        (r, c), path = queue.popleft()

        if (r, c) == base:
            return path  # found a base, return the path

        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr][nc] == 1 and (nr, nc) not in visited:
                    queue.append(((nr, nc), path + [(nr, nc)]))
                    visited.add((nr, nc))
    return []

def find_all_remaining_worker_paths(parsed_combined_map, worker_map, worker_coords, base_coord, resource_coords): #i gotta fix these
  all_paths = []

  for worker in worker_coords:
    parse_copy_map = copy.deepcopy(parsed_combined_map)
    if worker_map[worker[0]][worker[1]] > 1:
      path = bfs_find_one_worker_path_to_base(parse_copy_map, worker, base_coord)
    else:
      parse_copy_map[base_coord[0]][base_coord[1]] = 0 #don't go through base
      path = bfs_find_one_worker_path_to_resource(parse_copy_map, worker, resource_coords)
      parse_copy_map[base_coord[0]][base_coord[1]] = 1 #pls go through base
      for resource in resource_coords: #make all resources unwalkcable, if they are in map??
        if 0 <= resource[0] < len(parse_copy_map) and 0 <= resource[1] < len(parse_copy_map[0]):
          parse_copy_map[resource[0]][resource[1]] = 0
        # else:
        #   print(f"Invalid resource coordinates: {resource}")

      if not path or len(path) < 2: #added < 2 to fix bug
        all_paths.append(path)
        continue


      path2 = bfs_find_one_worker_path_to_base(parse_copy_map, path[-2], base_coord)
      if not path2: #MEEEEEP
        continue

      path.extend(path2)
    all_paths.append(path)
  return all_paths

#these variables will have to be changed with the actual code files
def caclulate_path_rates(all_paths, worker_speed = 1, harvest_time = 2, deposit_time = 1): #this is kinda buggy, check photos on phone
  if all_paths == []:
    return [] #idk we can do something here.[math.inf]
  gold_rates_per_path = []

  for path in all_paths:
    if path == []:
      gold_rates_per_path.append(math.inf)
      continue
    time_for_path = ((len(path)-4)/worker_speed) + harvest_time + deposit_time #-4 (-1 on a tile already, -1 don't have to "leave" resource, -2 for harvest and deposit steps)
    if time_for_path == 0:
      gold_rates_per_path.append(math.inf)
    else:
      gold_rates_per_path.append(time_for_path)


  return gold_rates_per_path

def visualize_the_gird(worker_map, base_map, resource_map, barracks_map):
  for r in range(4):
    row = []
    for c in range(4):
        if   worker_map[r][c] == 1:        row.append("👨🏻")
        elif base_map[r][c]   == 1:        row.append("🏠")
        elif resource_map[r][c]== 1:       row.append("❇️")
        elif barracks_map[r][c]== 1:       row.append("🏯")
        else:                              row.append("◼️")
    print(row)

def pathfinding(worker_map, base_map, resource_map, barracks_map):
  #getting base coordinates
  coords = [(r, c) for r, row in enumerate(base_map) for c, val in enumerate(row) if val == 1] #change base_coord, #tesnor, tells you where the tensors are non 0
  if coords:
    base_coord = coords[0]  
  else:
    return [math.inf], [math.inf], None

  #making a grid suitable for pathfinding
  parsed_combined_map = [] #just add barracks map
  for r in range(len(worker_map)):
    row = []
    for c in range(len(worker_map[r])):
      row.append(0 if (barracks_map[r][c] == 1) else 1)
    parsed_combined_map.append(row)

  #print("Walkable Map:")
  #for row in parsed_combined_map:
    #print(row)

  #print("Game Map:")
  #visualize_the_gird(worker_map, base_map, resource_map, barracks_map)

  #get worker coords
  worker_coords = [] #tesnor, tells you where the tensors are non 0
  for r in range(len(worker_map)):
    for c in range(len(worker_map[r])):
      if worker_map[r][c] >= 1:
        worker_coords.append((r, c))



  #get resource coords, #tesnor, tells you where the tensors are non 0
  resource_coords = []
  for r in range(len(resource_map)):
      for c in range(len(resource_map[r])):
          if resource_map[r][c] == 1:
              resource_coords.append((r, c))

  if resource_coords == []: #if no resoruces found, set paths to infinity
    return [math.inf], [math.inf], base_coord

  #if no workers found, i think this would work without this
  if worker_coords == []:
    paths = []
  else:
    paths = find_all_remaining_worker_paths(parsed_combined_map, worker_map, worker_coords, base_coord, resource_coords)



  #finally, get our optimal paths from base to resources
  bfs_paths = find_all_paths_to_resources(parsed_combined_map, base_coord, resource_coords)

  #current paths
  
  #for row in paths:
    #print(row)

  return caclulate_path_rates(bfs_paths), caclulate_path_rates(paths), base_coord
  #returns the optimal paths, and the current paths

#@title RandomGen
def randomNum():
    return random.randint(0, 3), random.randint(0, 3)

def pad_to_corner(og_map, owner_id=0, size=16, pad_value=0):
    arr = np.array(og_map)
    h, w = arr.shape
    
    # print(f"\nOG MAP with owner: {owner_id}")
    # for row in og_map:
    #   print(row)

    # 2) Prepare the output
    out = np.full((size, size), pad_value, dtype=arr.dtype)

    # 3) Copy into the correct corner
    if owner_id == 0:
        out[:h, :w] = arr
    else:
        out[-h:, -w:] = arr

    # print(f"\nNEW MAP with owner: {owner_id}")
    # for row in out:
    #   print(row)

    return out

    

    

def generateRandArray(num_workers, num_resources, num_barracks, num_base=1, passed_id=0):
    hash_map = {}
    hash_map[0] = num_workers
    hash_map[1] = num_base
    hash_map[2] = num_resources
    hash_map[3] = num_barracks
    arrays = [
    [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
    ],
    [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ],
    [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ],
    [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ]
]
    visited = set()
    idx = 0
    for arr in arrays:
      for i in range(hash_map[idx]):
        x, y = randomNum()
        # if it’s already been used, pick again until it isn’t
        while (x, y) in visited:
            x, y = randomNum()

        # now x and y are valid integers and not in visited
        arr[x][y] = 1
        visited.add((x, y))
      idx += 1

    for i, arr in enumerate(arrays):
      arrays[i] = pad_to_corner(arr, owner_id=passed_id, size=16, pad_value=0)

    return arrays

### ---------- STATE CLASS ---------- ###
class State:
    def calculate_gold_rate(worker_num, worker_paths):
      return 5

    def __init__(self, state_vector, time_vector=None, time_till=0, action_history=None, parent=None, military_strength = 0):
        self.state_vector = np.array(state_vector, dtype=int)
        self.time_vector = defaultdict(list)
        if time_vector:
            for k, v_list in time_vector.items():
                self.time_vector[k] = v_list.copy()
        self.time_till = time_till
        self.action_history = action_history or []
        self.parent = parent
        self.military_strength = military_strength
        self.children = []

    #make a print action function here, NAH

    def __lt__(self, other): #comparison for the minheap
        return self.time_till < other.time_till


### ---------- ACTION & EVENT DEFINITIONS ---------- ###

ACTION_VECTORS = { #how it affects the state on the action, CHANGE THESE TO THE REAL ONE
    "wait":{
        "cost": 0,
        "state_vector": [0, 0, 0, 0, 0, 0, 0, 0], #[gold, workers, light, heavy, ragned, barracks, active_barracks, attack_worker]
        "time_add": None,
        "requirements": {}
    },
    "buy_worker": { # produce time = 50
        "cost": 1,
        "state_vector": [-1, 0, 0, 0, 0, 0, 0, 0],
        "time_add": (1, 5),
        "requirements": {}
    },
    "buy_barrack": { # produce time = 200
        "cost": 5,
        "state_vector": [-5, 0, 0, 0, 0, 0, 0, 0],
        "time_add": (5, 20),
        "requirements": {}
    },
    "buy_light": { # produce time = 80
        "cost": 2,
        "state_vector": [-2, 0, 0, 0, 0, 0, -1, 0],
        "time_add": (2, 8),
        "requirements": {"active_barracks": 1}
    },
    "buy_heavy": { # produce time = 120
        "cost": 2,
        "state_vector": [-2, 0, 0, 0, 0, 0, -1, 0],
        "time_add": (3, 12),
        "requirements": {"active_barracks": 1}
    },
    "buy_ranged": { # produce time = 100
        "cost": 2,
        "state_vector": [-2, 0, 0, 0, 0, 0, -1, 0],
        "time_add": (4, 10),
        "requirements": {"active_barracks": 1}
    },
    "buy_attack_worker": {
        "cost": 2,
        "state_vector": [-2, 0, 0, 0, 0, 0, 0, 0],
        "time_add": (7, 5),
        "requirements": {}
    }

}

EVENT_VECTORS = { #when that timer drops to 0
    0: np.array([1, 0, 0, 0, 0, 0, 0, 0]),  #gold income, CHECK WHAT THE REAL VAL IS
    1: np.array([0, 1, 0, 0, 0, 0, 0, 0]),  #worker complete
    2: np.array([0, 0, 1, 0, 0, 0, 1, 0]),  #light complete
    3: np.array([0, 0, 0, 1, 0, 0, 1, 0]),  #heavy complete
    4: np.array([0, 0, 0, 0, 1, 0, 1, 0]),  #ranged complete
    5: np.array([0, 0, 0, 0, 0, 1, 1, 0]),  #barracks complete
    6: np.array([0, 0, 0, 0, 0, 0, 0, 0]),  #wait complete
    7: np.array([0, 0, 0, 0, 0, 0, 0, 1])   #attack worker complete
}

#MILITARY VALUES, this updates military strenght of node
mil_values = {
    0: 0, #gold, no
    1: 0, #econ worker, no
    2: 2, #light
    3: 2, #heavy
    4: 4, #ragned
    5: 0, #barracks, no
    6: 0, #wait, no
    7: 1  #attack_work
}

class militaryMaxList: #custom list from chatGPT to help us keep track of military strength FAST (logn) 
    def __init__(self):
        self.times = []    # e.g. [0, 3, 6, …]
        self.military_strengths = []   # e.g. [5, 8, 10, …]

    def add(self, t, ms):
        if self.military_strengths and ms <= self.military_strengths[-1]:
            return

        self.times.append(t)
        self.military_strengths.append(ms)

    def max_before(self, cutoff): #if cutoff is -1
        if not self.times:
          return 0
        if cutoff < self.times[0]:
          return self.military_strengths[0]

        lo, hi = 0, len(self.times) - 1
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if self.times[mid] <= cutoff:
                lo = mid
            else:
                hi = mid - 1

        return self.military_strengths[lo]


class GameTree: #add owner id and t_rush 
    def __init__(self, initial_state_vector, initial_time_vector, optimal_time_vector_workers, owner_id, t_rush, enemy_max_mil_arr=None, hard_wait=7, runtime_limit=0.05): #deal with the hard_wait thing, also think of a dif name, maybe only make it kick in with no other triggers
        self.root = State(
            state_vector=np.array(initial_state_vector),
            time_vector=initial_time_vector,
            time_till=0,
            action_history=[],
            parent=None
        )
        self.root.time_vector[6].append(hard_wait)
        self.heap = [self.root] #minheap to expand
        self.visited = []
        self.hard_wait = hard_wait
        self.runtime_limit = runtime_limit
        self.optimal_time_vector_workers = optimal_time_vector_workers #for resetting
        if enemy_max_mil_arr == None:
          self.enemy_max_mil_arr = militaryMaxList()
        else:
          self.enemy_max_mil_arr = enemy_max_mil_arr
        self.owner_id=owner_id
        self.t_rush = t_rush


    def build(self):
      start_time = time.time()

      while self.heap and (time.time() - start_time) < self.runtime_limit:
          current = self.heap[0] #peek the top

          self.expand_state(current) #generate kids and push them in
          
          heapq.heappop(self.heap) #pop the top

          self.visited.append(current)  #just to track, dw king, chat said to add for debugging and for checking stats after (like evaluation)
      #return current #only doing this to test out my output function, REMOVE LATER

    def simulate_time_forward(self, state):
      #all timers across all keys
      all_times = [t for timers in state.time_vector.values() for t in timers if t > 0]
      if not all_times:
          return None, None, 0

      min_time = min(all_times)

      new_time_vector = defaultdict(list)
      new_state_vector = state.state_vector.copy()
      military_change = 0

      for key, timers in state.time_vector.items():
          for idx, t in enumerate(timers):
              remaining = t - min_time
              if remaining <= 0:
                  military_change += mil_values[key]
                  #if the timer is 0 then apply event
                  new_state_vector += EVENT_VECTORS.get(key, np.zeros(8, dtype=int))
                  #reset the g/s (this would have to be automated depdending on worker to mineral resource patch)

                  if key == 0:
                      new_time_vector[key].append(self.optimal_time_vector_workers[0])
                  elif key == 1: #worker complete, so add a new timer
                      if new_state_vector[1] < len(self.optimal_time_vector_workers):
                        new_time_vector[0].append(self.optimal_time_vector_workers[new_state_vector[1] - 1])
                      else:
                        new_time_vector[0].append(math.inf)
                  elif key == 6:
                    new_time_vector[key].append(self.hard_wait)


              else:
                  new_time_vector[key].append(remaining)

      return new_state_vector, new_time_vector, min_time, military_change

    def is_action_valid(self, state, action_data):
      #check if we have gold for it
      if state.state_vector[0] < action_data["cost"]:
          return False

      #check extra requriements, which is just active barracks for now
      requirements = action_data.get("requirements", {})
      if "active_barracks" in requirements:
          if state.state_vector[6] < requirements["active_barracks"]:
              return False

      return True

    def expand_state(self, state):
      #moving time forward
      updated_sv, updated_tv, time_advanced, military_change = self.simulate_time_forward(state)
      if updated_sv is None:
          return  #no timers, so don't expand
      
      #add military here?? 


      #hidden state lol, to keep track of what we get after the timer is up
      pseudo_state = State(state_vector=updated_sv, time_vector=updated_tv, time_till=(state.time_till + time_advanced), military_strength=(state.military_strength + military_change))

      #check here if it should propogate
      #find max before this psuedo time
      if self.owner_id == 1:
        self.enemy_max_mil_arr.add(state.time_till, state.military_strength) #adding the parents state military sternght to max_mil_arr
      else:
        max_enemy_mil_t_rush_away = self.enemy_max_mil_arr.max_before(pseudo_state.time_till - self.t_rush) #this is the max enemy military strength before t_rush

      if self.owner_id == 1 or (self.owner_id == 0 and pseudo_state.military_strength >= (max_enemy_mil_t_rush_away - 3)): #-3 is a buffer
        for action_name, action_data in ACTION_VECTORS.items():
            if self.is_action_valid(pseudo_state, action_data):
                #apply state vector
                new_sv = updated_sv + np.array(action_data["state_vector"])

                #timing stuff, chat helped with this :O
                new_tv = defaultdict(list)
                for k, v in updated_tv.items():
                    new_tv[k] = v.copy()

                if action_data["time_add"]:
                    idx, val = action_data["time_add"]
                    new_tv[idx].append(val)

                #the new kid
                child = State(
                    state_vector=new_sv,
                    time_vector=new_tv,
                    time_till=pseudo_state.time_till,
                    action_history=state.action_history + [action_name], #action_history=state.action_history + [f"wait {time_advanced}s", action_name],
                    parent=state,
                    military_strength=pseudo_state.military_strength
                )

                #run wtvr you wanna do for the min_heap

                #add child to both tree and the minheap
                state.children.append(child)
                heapq.heappush(self.heap, child)    

    def print_tree(self, max_depth=None):
      def dfs(node, depth):
          indent = "    " * depth
          print(f"{indent}- Time: {node.time_till}")
          print(f"{indent}  State: {node.state_vector}")
          print(f"{indent}  Time Vector: {node.time_vector}")
          print(f"{indent}  Mil_strength: {node.military_strength}\n")
          print(f"{indent}  Actions: {' -> '.join(node.action_history)}\n")

          if max_depth is not None and depth >= max_depth:
              return

          for child in node.children:
              dfs(child, depth + 1)

      print("\nGame Tree:\n")
      dfs(self.root, 0)

output_vectors = {
    "buy_barrack":       torch.tensor([0, 0, 1, 0, 0, 0, 0], dtype=torch.float32),
    "buy_worker":        torch.tensor([0, 0, 0, 1, 0, 0, 0], dtype=torch.float32),
    "buy_light":         torch.tensor([0, 0, 0, 0, 1, 0, 0], dtype=torch.float32),
    "buy_heavy":         torch.tensor([0, 0, 0, 0, 0, 1, 0], dtype=torch.float32),
    "buy_ranged":        torch.tensor([0, 0, 0, 0, 0, 0, 1], dtype=torch.float32),
    "buy_attack_worker": torch.tensor([0, 0, 0, 1, 0, 0, 0], dtype=torch.float32),
    "wait": torch.tensor([0, 0, 0, 0, 0, 0, 0], dtype=torch.float32),
}

#output_vectors["wait"] = [0, 0, 0, 0, 0, 0, 0] #perhaps get rid of this

def get_action_recommendation(state, num_of_actions = 3):
  output_vector = [] #cadfsfgaergaerg
  if state == None:
    return [torch.zeros(7) for _ in range(3)]

  #print(state.action_history)
  for action in state.action_history:
    if (len(state.action_history) ==  len(output_vector)) or len(output_vector) == num_of_actions:
      break
    if action in output_vectors:
      output_vector.append(output_vectors[action])
  if len(output_vector) < num_of_actions:
    for i in range(num_of_actions - len(output_vector)):
      if output_vector:
        output_vector.append(output_vector[0]) #just copy the first one, output_vector.append([0, 0, 0, 0, 0, 0, 0])
      else:
        output_vector.append(torch.tensor([0, 0, 0, 0, 0, 0, 0], dtype=torch.float32))
  return output_vector

def find_t_rush(coord1, coord2):
    x1, y1 = coord1
    x2, y2 = coord2
    return (abs(x1 - x2) + abs(y1 - y2))/1 #T_rush is slightly 


def evaluate_best_leaf(our_tree, enemy_tree, T_rush, optimal_path_rates):
    # 1) Flatten both trees
    def flatten(root):
        stack, out = [root], []
        while stack:
            node = stack.pop()
            out.append(node)
            stack.extend(node.children)
        return out

    leaves  = [n for n in flatten(our_tree.root) if not n.children]
    enemies = flatten(enemy_tree.root)

    # 2) Sort enemy nodes by time_till and build a prefix-max over their strengths
    enemies.sort(key=lambda n: n.time_till)
    times   = [n.time_till for n in enemies]
    strengths = [n.military_strength for n in enemies]
    prefix_max = []
    running_max = float('-inf')
    for s in strengths:
        running_max = max(running_max, s)
        prefix_max.append(running_max)

    # 3) Walk through leaves, binary-search the cutoff, compute score, and track the best
    best_leaf  = None
    best_score = float('-inf')

    military_score = 1
    active_worker_score = 10

    for leaf in leaves:
        cutoff = leaf.time_till - T_rush
        idx = bisect.bisect_left(times, cutoff)
        if idx < 0: #changed from == to allow for 
            continue  # no valid enemy before cutoff
        enemy_best = prefix_max[idx - 1]
        score = military_score * (leaf.military_strength - enemy_best) + (active_worker_score * (1 - abs(leaf.state_vector[1] - len(optimal_path_rates)))) + 10 * leaf.state_vector[5] + 13 * min(0,leaf.state_vector[5] - leaf.state_vector[6]) #barracks - available_barracks

        if score > best_score:
            best_score = score
            best_leaf  = leaf

    return best_leaf

def generateForBatch(batch_num=100): #for testing
  # these will hold per‐example tensors
  scalars_user       = []
  worker_maps_user   = []
  barracks_maps_user = []
  resource_maps_user = []
  base_maps_user     = []

  scalars_enemy       = []
  worker_maps_enemy   = []
  barracks_maps_enemy = []
  resource_maps_enemy = []
  base_maps_enemy     = []

  for i in range(batch_num):
      # build your raw data

      # draws three ints in [0,3), i.e. 0,1,2
      work_num, res_num, barr_num = np.random.randint(0, 3, size=3)


      user_state_vector  = [5, work_num, 0, 0, 0, barr_num, barr_num, 0]
      enemy_state_vector = [5, work_num, 0, 0, 0, barr_num, barr_num, 0]
      user_arrays  = generateRandArray(work_num, res_num, barr_num, passed_id=0)
      enemy_arrays = generateRandArray(work_num, res_num, barr_num, passed_id=1)

      # convert each piece to a torch.Tensor *before* appending
      scalars_user.append(torch.tensor(user_state_vector, dtype=torch.float32))
      worker_maps_user.append(torch.tensor(user_arrays[0],    dtype=torch.float32))
      barracks_maps_user.append(torch.tensor(user_arrays[3],  dtype=torch.float32))
      resource_maps_user.append(torch.tensor(user_arrays[2],  dtype=torch.float32))
      base_maps_user.append(torch.tensor(user_arrays[1],      dtype=torch.float32))

      scalars_enemy.append(torch.tensor(enemy_state_vector, dtype=torch.float32))
      worker_maps_enemy.append(torch.tensor(enemy_arrays[0],    dtype=torch.float32))
      barracks_maps_enemy.append(torch.tensor(enemy_arrays[3],  dtype=torch.float32))
      resource_maps_enemy.append(torch.tensor(enemy_arrays[2],  dtype=torch.float32))
      base_maps_enemy.append(torch.tensor(enemy_arrays[1],      dtype=torch.float32))

  # now stack each list of [batch] tensors into a single [batch, …] tensor
  scalars_user       = torch.stack(scalars_user,       dim=0)  # shape: [batch_num, 8]
  worker_maps_user   = torch.stack(worker_maps_user,   dim=0)  # shape: [batch_num, work_num, …]
  barracks_maps_user = torch.stack(barracks_maps_user, dim=0)
  resource_maps_user = torch.stack(resource_maps_user, dim=0)
  base_maps_user     = torch.stack(base_maps_user,     dim=0)

  scalars_enemy       = torch.stack(scalars_enemy,       dim=0)
  worker_maps_enemy   = torch.stack(worker_maps_enemy,   dim=0)
  barracks_maps_enemy = torch.stack(barracks_maps_enemy, dim=0)
  resource_maps_enemy = torch.stack(resource_maps_enemy, dim=0)
  base_maps_enemy     = torch.stack(base_maps_enemy,     dim=0)

  # now your `batch` can be:
  user_batch  = (scalars_user,       worker_maps_user,   barracks_maps_user,
                resource_maps_user, base_maps_user)
  enemy_batch = (scalars_enemy,       worker_maps_enemy,   barracks_maps_enemy,
                resource_maps_enemy, base_maps_enemy)

  batch = (user_batch, enemy_batch)
  return batch

def executeTwoTrees(inputs_for_both_trees):
    u_optimal_path_rates, u_current_path_rates, u_base_coord = pathfinding(inputs_for_both_trees[0][1], inputs_for_both_trees[0][4], inputs_for_both_trees[0][3], inputs_for_both_trees[0][2]) #worker,base, resources, barracks
    e_optimal_path_rates, e_current_path_rates, e_base_coord = pathfinding(inputs_for_both_trees[1][1], inputs_for_both_trees[1][4], inputs_for_both_trees[1][3], inputs_for_both_trees[1][2])

    if u_base_coord == None:
      output_tensor = [torch.zeros(7) for _ in range(3)]
      output_tensor = torch.cat(output_tensor, dim=0)
      return output_tensor
    elif e_base_coord == None: #what to do when e_base_coord == none
      t_rush = math.inf
    else:
      t_rush = find_t_rush(u_base_coord, e_base_coord) 

    enemy_tree = GameTree(inputs_for_both_trees[1][0], {0: e_current_path_rates}, e_optimal_path_rates, 1,  t_rush, runtime_limit=0.002) #0.002
    our_tree = GameTree(inputs_for_both_trees[0][0], {0: u_current_path_rates}, u_optimal_path_rates, 0, t_rush, runtime_limit=0.002) #runtime limitation
    
    enemy_tree.build()
    our_tree.build()

    if our_tree.root == None or enemy_tree.root == None: #bandaid fix
      output_tensor = [torch.zeros(7) for _ in range(3)]
      output_tensor = torch.cat(output_tensor, dim=0)
      return output_tensor

    best_leaf_recommendations = evaluate_best_leaf(our_tree, enemy_tree, t_rush, u_optimal_path_rates)
    output_tensor = get_action_recommendation(best_leaf_recommendations) #list of three tensors
    output_tensor = torch.cat(output_tensor, dim=0)

    return output_tensor

def bigBatch(tree_input):
    owner1, owner2 = tree_input
    scalars1, worker_map1, barracks_map1, resource_map1, base_map1 = owner1
    scalars2, worker_map2, barracks_map2, resource_map2, base_map2 = owner2
    batch_num = scalars1.shape[0]

    # 1) prepare all of your inputs for parallel execution
    tasks = []
    for i in range(batch_num):
        tasks.append([
            [scalars1[i,:],  worker_map1[i],  barracks_map1[i],
             resource_map1[i], base_map1[i]],
            [scalars2[i,:],  worker_map2[i],  barracks_map2[i],
             resource_map2[i], base_map2[i]]
        ])

    # 2) spawn a pool and map
    with Pool(processes=cpu_count()) as pool:
        results = pool.map(executeTwoTrees, tasks)
 
    return torch.stack(results, dim=0)